<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Veles Alpha Output</title>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
      cursor: none;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <canvas id="output"></canvas>
  <script>
    /**
     * Alpha / Key Output Window — WebGL renderer for luma key BGRA frames.
     * Receives pre-extracted alpha-as-grayscale from OutputManager.
     * White = opaque, Black = transparent.
     * GPU-accelerated: texture upload + R/B swizzle in fragment shader.
     */
    const canvas = document.getElementById('output');
    const gl = canvas.getContext('webgl', { antialias: false, preserveDrawingBuffer: false });

    if (!gl) {
      // Fallback to 2D canvas if WebGL unavailable
      document.title = 'Veles Alpha Output (2D fallback)';
      const ctx = canvas.getContext('2d');
      if (window.outputAPI) {
        window.outputAPI.onFrame((data) => {
          const { buffer, width, height } = data;
          if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width; canvas.height = height;
          }
          const px = new Uint8ClampedArray(buffer);
          for (let i = 0; i < px.length; i += 4) {
            const b = px[i]; px[i] = px[i+2]; px[i+2] = b; px[i+3] = 255;
          }
          ctx.putImageData(new ImageData(px, width, height), 0, 0);
        });
      }
    } else {
      // ── WebGL setup ──
      const vsrc = `
        attribute vec2 aPos;
        varying vec2 vUV;
        void main() {
          vUV = aPos * 0.5 + 0.5;
          vUV.y = 1.0 - vUV.y;
          gl_Position = vec4(aPos, 0.0, 1.0);
        }`;
      const fsrc = `
        precision mediump float;
        varying vec2 vUV;
        uniform sampler2D uTex;
        void main() {
          vec4 c = texture2D(uTex, vUV);
          gl_FragColor = vec4(c.b, c.g, c.r, 1.0);
        }`;

      function compile(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        return s;
      }

      const prog = gl.createProgram();
      gl.attachShader(prog, compile(gl.VERTEX_SHADER, vsrc));
      gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fsrc));
      gl.linkProgram(prog);
      gl.useProgram(prog);

      // Full-screen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
      const aPos = gl.getAttribLocation(prog, 'aPos');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      // Texture
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      var lastW = 0, lastH = 0;

      if (window.outputAPI) {
        window.outputAPI.onFrame((data) => {
          const { buffer, width, height } = data;

          if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            gl.viewport(0, 0, width, height);
          }

          gl.bindTexture(gl.TEXTURE_2D, tex);
          const pixels = new Uint8Array(buffer);

          if (lastW !== width || lastH !== height) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            lastW = width; lastH = height;
          } else {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          }

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        });
      }
    }

    // Keyboard handling
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.fullscreenElement) document.exitFullscreen();
      if (e.key === 'F11') {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
      }
    });
  </script>
</body>
</html>
